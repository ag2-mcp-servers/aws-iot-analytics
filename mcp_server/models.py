# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:04:45+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint, constr


class ActivityBatchSize(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ActivityName(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class AttributeName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class AttributeNameMapping(RootModel[Optional[Dict[str, AttributeName]]]):
    root: Optional[Dict[str, AttributeName]] = None


class AttributeNames(RootModel[List[AttributeName]]):
    root: List[AttributeName] = Field(..., max_length=50, min_length=1)


class BucketKeyExpression(
    RootModel[
        constr(pattern=r'^[a-zA-Z0-9!_.*\'()/{}:-]*$', min_length=1, max_length=255)
    ]
):
    root: constr(pattern=r'^[a-zA-Z0-9!_.*\'()/{}:-]*$', min_length=1, max_length=255)


class BucketName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9.\-_]*$', min_length=3, max_length=255)]
):
    root: constr(pattern=r'^[a-zA-Z0-9.\-_]*$', min_length=3, max_length=255)


class CancelPipelineReprocessingRequest(BaseModel):
    pass


class CancelPipelineReprocessingResponse(BaseModel):
    pass


class ChannelArn(RootModel[str]):
    root: str


class ChannelName(
    RootModel[
        constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)


class ChannelStatus(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    DELETING = 'DELETING'


class ColumnDataType(RootModel[constr(min_length=1, max_length=131072)]):
    root: constr(min_length=1, max_length=131072)


class ColumnName(
    RootModel[
        constr(
            pattern=r'^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$',
            min_length=1,
            max_length=255,
        )
    ]
):
    root: constr(
        pattern=r'^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$',
        min_length=1,
        max_length=255,
    )


class ComputeType(Enum):
    ACU_1 = 'ACU_1'
    ACU_2 = 'ACU_2'


class DatasetActionName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9_]+$', min_length=1, max_length=128)]
):
    root: constr(pattern=r'^[a-zA-Z0-9_]+$', min_length=1, max_length=128)


class DatasetActionType(Enum):
    QUERY = 'QUERY'
    CONTAINER = 'CONTAINER'


class DatasetArn(RootModel[str]):
    root: str


class DatasetContentState(Enum):
    CREATING = 'CREATING'
    SUCCEEDED = 'SUCCEEDED'
    FAILED = 'FAILED'


class DatasetContentVersion(RootModel[constr(min_length=7, max_length=36)]):
    root: constr(min_length=7, max_length=36)


class DatasetName(
    RootModel[
        constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)


class DatasetStatus(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    DELETING = 'DELETING'


class DatastoreArn(RootModel[str]):
    root: str


class DatastoreName(
    RootModel[
        constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)


class DatastoreStatus(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    DELETING = 'DELETING'


class DeleteChannelRequest(BaseModel):
    pass


class DeleteDatasetContentRequest(BaseModel):
    pass


class DeleteDatasetRequest(BaseModel):
    pass


class DeleteDatastoreRequest(BaseModel):
    pass


class DeletePipelineRequest(BaseModel):
    pass


class DescribeChannelRequest(BaseModel):
    pass


class DescribeDatasetRequest(BaseModel):
    pass


class DescribeDatastoreRequest(BaseModel):
    pass


class DescribeLoggingOptionsRequest(BaseModel):
    pass


class DescribePipelineRequest(BaseModel):
    pass


class DoubleValue(RootModel[float]):
    root: float


class EndTime(RootModel[datetime]):
    root: datetime


class EntryName(RootModel[str]):
    root: str


class ErrorCode(RootModel[str]):
    root: str


class ErrorMessage(RootModel[str]):
    root: str


class FileFormatType(Enum):
    JSON = 'JSON'
    PARQUET = 'PARQUET'


class FilterExpression(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class GetDatasetContentRequest(BaseModel):
    pass


class GlueDatabaseName(RootModel[constr(min_length=1, max_length=150)]):
    root: constr(min_length=1, max_length=150)


class GlueTableName(RootModel[constr(min_length=1, max_length=150)]):
    root: constr(min_length=1, max_length=150)


class Image(RootModel[constr(max_length=255)]):
    root: constr(max_length=255)


class IncludeStatisticsFlag(RootModel[bool]):
    root: bool


class InternalFailureException(RootModel[Any]):
    root: Any


class InvalidRequestException(RootModel[Any]):
    root: Any


class IotEventsInputName(
    RootModel[constr(pattern=r'^[a-zA-Z][a-zA-Z0-9_]*$', min_length=1, max_length=128)]
):
    root: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9_]*$', min_length=1, max_length=128)


class JsonConfiguration(BaseModel):
    pass


class LambdaName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9_-]+$', min_length=1, max_length=64)]
):
    root: constr(pattern=r'^[a-zA-Z0-9_-]+$', min_length=1, max_length=64)


class LateDataRuleName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9_]+$', min_length=1, max_length=128)]
):
    root: constr(pattern=r'^[a-zA-Z0-9_]+$', min_length=1, max_length=128)


class LimitExceededException(RootModel[Any]):
    root: Any


class ListChannelsRequest(BaseModel):
    pass


class ListDatasetContentsRequest(BaseModel):
    pass


class ListDatasetsRequest(BaseModel):
    pass


class ListDatastoresRequest(BaseModel):
    pass


class ListPipelinesRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class LogResult(RootModel[str]):
    root: str


class LoggingEnabled(RootModel[bool]):
    root: bool


class LoggingLevel(Enum):
    ERROR = 'ERROR'


class MathExpression(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class MaxMessages(RootModel[conint(ge=1, le=10)]):
    root: conint(ge=1, le=10)


class MaxResults(RootModel[conint(ge=1, le=250)]):
    root: conint(ge=1, le=250)


class MaxVersions(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class MessageId(RootModel[constr(pattern=r'\p{ASCII}*', min_length=1, max_length=128)]):
    root: constr(pattern=r'\p{ASCII}*', min_length=1, max_length=128)


class MessagePayload(RootModel[str]):
    root: str


class MessagePayloads(RootModel[List[MessagePayload]]):
    root: List[MessagePayload] = Field(..., max_length=10, min_length=1)


class NextToken(RootModel[str]):
    root: str


class OffsetSeconds(RootModel[int]):
    root: int


class OutputFileName(RootModel[constr(pattern=r'[\w\.-]{1,255}')]):
    root: constr(pattern=r'[\w\.-]{1,255}')


class OutputFileUriValue(BaseModel):
    fileName: OutputFileName


class PartitionAttributeName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9_]+$', min_length=1, max_length=128)]
):
    root: constr(pattern=r'^[a-zA-Z0-9_]+$', min_length=1, max_length=128)


class PipelineArn(RootModel[str]):
    root: str


class PipelineName(
    RootModel[
        constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128)


class PresignedURI(RootModel[str]):
    root: str


class Reason(RootModel[str]):
    root: str


class RemoveAttributesActivity(BaseModel):
    attributes: AttributeNames
    name: ActivityName
    next: Optional[ActivityName] = None


class ReprocessingId(RootModel[str]):
    root: str


class ReprocessingStatus(Enum):
    RUNNING = 'RUNNING'
    SUCCEEDED = 'SUCCEEDED'
    CANCELLED = 'CANCELLED'
    FAILED = 'FAILED'


class ResourceAlreadyExistsException(RootModel[Any]):
    root: Any


class ResourceArn(RootModel[constr(min_length=20, max_length=2048)]):
    root: constr(min_length=20, max_length=2048)


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class RetentionPeriodInDays(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class RoleArn(RootModel[constr(min_length=20, max_length=2048)]):
    root: constr(min_length=20, max_length=2048)


class RunPipelineActivityResponse(BaseModel):
    logResult: Optional[LogResult] = None
    payloads: Optional[MessagePayloads] = None


class S3KeyPrefix(
    RootModel[
        constr(pattern=r'^[a-zA-Z0-9!_.*\'()/{}:-]*/$', min_length=1, max_length=255)
    ]
):
    root: constr(pattern=r'^[a-zA-Z0-9!_.*\'()/{}:-]*/$', min_length=1, max_length=255)


class S3PathChannelMessage(
    RootModel[
        constr(
            pattern=r'^[a-zA-Z0-9/_!\'(){}\*\s\.\-\=\:]+$',
            min_length=1,
            max_length=1024,
        )
    ]
):
    root: constr(
        pattern=r'^[a-zA-Z0-9/_!\'(){}\*\s\.\-\=\:]+$', min_length=1, max_length=1024
    )


class S3PathChannelMessages(RootModel[List[S3PathChannelMessage]]):
    root: List[S3PathChannelMessage] = Field(..., max_length=100, min_length=1)


class SampleChannelDataRequest(BaseModel):
    pass


class SampleChannelDataResponse(BaseModel):
    payloads: Optional[MessagePayloads] = None


class ScheduleExpression(RootModel[str]):
    root: str


class SelectAttributesActivity(BaseModel):
    attributes: AttributeNames
    name: ActivityName
    next: Optional[ActivityName] = None


class ServiceManagedChannelS3Storage(BaseModel):
    pass


class ServiceManagedChannelS3StorageSummary(BaseModel):
    pass


class ServiceManagedDatastoreS3Storage(BaseModel):
    pass


class ServiceManagedDatastoreS3StorageSummary(BaseModel):
    pass


class ServiceUnavailableException(RootModel[Any]):
    root: Any


class SessionTimeoutInMinutes(RootModel[conint(ge=1, le=60)]):
    root: conint(ge=1, le=60)


class SizeInBytes(RootModel[float]):
    root: float


class SqlQuery(RootModel[str]):
    root: str


class StartPipelineReprocessingResponse(BaseModel):
    reprocessingId: Optional[ReprocessingId] = None


class StartTime(RootModel[datetime]):
    root: datetime


class StringValue(RootModel[constr(min_length=0, max_length=1024)]):
    root: constr(min_length=0, max_length=1024)


class TagKey(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class TagResourceResponse(BaseModel):
    pass


class TagValue(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ThrottlingException(RootModel[Any]):
    root: Any


class TimeExpression(RootModel[str]):
    root: str


class Timestamp(RootModel[datetime]):
    root: datetime


class TimestampFormat(
    RootModel[
        constr(pattern=r'^[a-zA-Z0-9\s\[\]_,.\'/:-]*$', min_length=1, max_length=50)
    ]
):
    root: constr(pattern=r'^[a-zA-Z0-9\s\[\]_,.\'/:-]*$', min_length=1, max_length=50)


class TimestampPartition(BaseModel):
    attributeName: PartitionAttributeName
    timestampFormat: Optional[TimestampFormat] = None


class TriggeringDataset(BaseModel):
    name: DatasetName


class UnlimitedRetentionPeriod(RootModel[bool]):
    root: bool


class UnlimitedVersioning(RootModel[bool]):
    root: bool


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResponse(BaseModel):
    pass


class VariableName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class VersioningConfiguration(BaseModel):
    maxVersions: Optional[MaxVersions] = None
    unlimited: Optional[UnlimitedVersioning] = None


class VolumeSizeInGB(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class RetentionPeriod(BaseModel):
    numberOfDays: Optional[RetentionPeriodInDays] = None
    unlimited: Optional[UnlimitedRetentionPeriod] = None


class DatasetsDatasetNameContentPostRequest(BaseModel):
    versionId: Optional[constr(min_length=7, max_length=36)] = Field(
        None,
        description='The version ID of the dataset content. To specify <code>versionId</code> for a dataset content, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a> filter.',
    )


class LoggingOptions1(BaseModel):
    enabled: Optional[LoggingEnabled] = None
    level: Optional[LoggingLevel] = None
    roleArn: Optional[RoleArn] = None


class LoggingPutRequest(BaseModel):
    loggingOptions: LoggingOptions1 = Field(
        ..., description='Information about logging options.'
    )


class ChannelMessages(BaseModel):
    s3Paths: Optional[S3PathChannelMessages] = None


class PipelinesPipelineNameReprocessingPostRequest(BaseModel):
    channelMessages: Optional[ChannelMessages] = Field(
        None, description='Specifies one or more sets of channel messages.'
    )
    endTime: Optional[datetime] = Field(
        None,
        description='<p>The end time (exclusive) of raw message data that is reprocessed.</p> <p>If you specify a value for the <code>endTime</code> parameter, you must not use the <code>channelMessages</code> object.</p>',
    )
    startTime: Optional[datetime] = Field(
        None,
        description='<p>The start time (inclusive) of raw message data that is reprocessed.</p> <p>If you specify a value for the <code>startTime</code> parameter, you must not use the <code>channelMessages</code> object.</p>',
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class AddAttributesActivity(BaseModel):
    attributes: AttributeNameMapping
    name: ActivityName
    next: Optional[ActivityName] = None


class BatchPutMessageErrorEntry(BaseModel):
    errorCode: Optional[ErrorCode] = None
    errorMessage: Optional[ErrorMessage] = None
    messageId: Optional[MessageId] = None


class ChannelActivity(BaseModel):
    channelName: ChannelName
    name: ActivityName
    next: Optional[ActivityName] = None


class Column(BaseModel):
    name: ColumnName
    type: ColumnDataType


class Columns(RootModel[List[Column]]):
    root: List[Column]


class CreateDatasetContentRequest(BaseModel):
    versionId: Optional[DatasetContentVersion] = None


class CreateDatasetContentResponse(BaseModel):
    versionId: Optional[DatasetContentVersion] = None


class CreatePipelineResponse(BaseModel):
    pipelineArn: Optional[PipelineArn] = None
    pipelineName: Optional[PipelineName] = None


class CustomerManagedChannelS3Storage(BaseModel):
    bucket: BucketName
    keyPrefix: Optional[S3KeyPrefix] = None
    roleArn: RoleArn


class CustomerManagedChannelS3StorageSummary(BaseModel):
    bucket: Optional[BucketName] = None
    keyPrefix: Optional[S3KeyPrefix] = None
    roleArn: Optional[RoleArn] = None


class CustomerManagedDatastoreS3Storage(BaseModel):
    bucket: BucketName
    keyPrefix: Optional[S3KeyPrefix] = None
    roleArn: RoleArn


class CustomerManagedDatastoreS3StorageSummary(BaseModel):
    bucket: Optional[BucketName] = None
    keyPrefix: Optional[S3KeyPrefix] = None
    roleArn: Optional[RoleArn] = None


class DatasetActionSummary(BaseModel):
    actionName: Optional[DatasetActionName] = None
    actionType: Optional[DatasetActionType] = None


class DatasetContentStatus(BaseModel):
    reason: Optional[Reason] = None
    state: Optional[DatasetContentState] = None


class DatasetContentSummary(BaseModel):
    completionTime: Optional[Timestamp] = None
    creationTime: Optional[Timestamp] = None
    scheduleTime: Optional[Timestamp] = None
    status: Optional[DatasetContentStatus] = None
    version: Optional[DatasetContentVersion] = None


class DatasetContentVersionValue(BaseModel):
    datasetName: DatasetName


class DatasetEntry(BaseModel):
    dataURI: Optional[PresignedURI] = None
    entryName: Optional[EntryName] = None


class DatastoreActivity(BaseModel):
    datastoreName: DatastoreName
    name: ActivityName


class DeltaTime(BaseModel):
    offsetSeconds: OffsetSeconds
    timeExpression: TimeExpression


class DeltaTimeSessionWindowConfiguration(BaseModel):
    timeoutInMinutes: SessionTimeoutInMinutes


class DeviceRegistryEnrichActivity(BaseModel):
    attribute: AttributeName
    name: ActivityName
    next: Optional[ActivityName] = None
    roleArn: RoleArn
    thingName: AttributeName


class DeviceShadowEnrichActivity(BaseModel):
    attribute: AttributeName
    name: ActivityName
    next: Optional[ActivityName] = None
    roleArn: RoleArn
    thingName: AttributeName


class EstimatedResourceSize(BaseModel):
    estimatedOn: Optional[Timestamp] = None
    estimatedSizeInBytes: Optional[SizeInBytes] = None


class FilterActivity(BaseModel):
    filter: FilterExpression
    name: ActivityName
    next: Optional[ActivityName] = None


class GlueConfiguration(BaseModel):
    databaseName: GlueDatabaseName
    tableName: GlueTableName


class IotEventsDestinationConfiguration(BaseModel):
    inputName: IotEventsInputName
    roleArn: RoleArn


class IotSiteWiseCustomerManagedDatastoreS3Storage(BaseModel):
    bucket: BucketName
    keyPrefix: Optional[S3KeyPrefix] = None


class IotSiteWiseCustomerManagedDatastoreS3StorageSummary(BaseModel):
    bucket: Optional[BucketName] = None
    keyPrefix: Optional[S3KeyPrefix] = None


class LambdaActivity(BaseModel):
    batchSize: ActivityBatchSize
    lambdaName: LambdaName
    name: ActivityName
    next: Optional[ActivityName] = None


class LateDataRuleConfiguration(BaseModel):
    deltaTimeSessionWindowConfiguration: Optional[
        DeltaTimeSessionWindowConfiguration
    ] = None


class LoggingOptions(BaseModel):
    enabled: LoggingEnabled
    level: LoggingLevel
    roleArn: RoleArn


class MathActivity(BaseModel):
    attribute: AttributeName
    math: MathExpression
    name: ActivityName
    next: Optional[ActivityName] = None


class Message(BaseModel):
    messageId: MessageId
    payload: MessagePayload


class Messages(RootModel[List[Message]]):
    root: List[Message]


class Partition(BaseModel):
    attributeName: PartitionAttributeName


class PipelineActivity(BaseModel):
    addAttributes: Optional[AddAttributesActivity] = None
    channel: Optional[ChannelActivity] = None
    datastore: Optional[DatastoreActivity] = None
    deviceRegistryEnrich: Optional[DeviceRegistryEnrichActivity] = None
    deviceShadowEnrich: Optional[DeviceShadowEnrichActivity] = None
    filter: Optional[FilterActivity] = None
    lambda_: Optional[LambdaActivity] = Field(None, alias='lambda')
    math: Optional[MathActivity] = None
    removeAttributes: Optional[RemoveAttributesActivity] = None
    selectAttributes: Optional[SelectAttributesActivity] = None


class PutLoggingOptionsRequest(BaseModel):
    loggingOptions: LoggingOptions


class QueryFilter(BaseModel):
    deltaTime: Optional[DeltaTime] = None


class QueryFilters(RootModel[List[QueryFilter]]):
    root: List[QueryFilter] = Field(..., max_length=1, min_length=0)


class ReprocessingSummary(BaseModel):
    creationTime: Optional[Timestamp] = None
    id: Optional[ReprocessingId] = None
    status: Optional[ReprocessingStatus] = None


class ResourceConfiguration(BaseModel):
    computeType: ComputeType
    volumeSizeInGB: VolumeSizeInGB


class RunPipelineActivityRequest(BaseModel):
    payloads: MessagePayloads
    pipelineActivity: PipelineActivity


class S3DestinationConfiguration(BaseModel):
    bucket: BucketName
    glueConfiguration: Optional[GlueConfiguration] = None
    key: BucketKeyExpression
    roleArn: RoleArn


class Schedule(BaseModel):
    expression: Optional[ScheduleExpression] = None


class SchemaDefinition(BaseModel):
    columns: Optional[Columns] = None


class SqlQueryDatasetAction(BaseModel):
    filters: Optional[QueryFilters] = None
    sqlQuery: SqlQuery


class StartPipelineReprocessingRequest(BaseModel):
    channelMessages: Optional[ChannelMessages] = None
    endTime: Optional[EndTime] = None
    startTime: Optional[StartTime] = None


class Tag(BaseModel):
    key: TagKey
    value: TagValue


class TagList(RootModel[List[Tag]]):
    root: List[Tag] = Field(..., max_length=50, min_length=1)


class TagResourceRequest(BaseModel):
    tags: TagList


class Variable(BaseModel):
    datasetContentVersionValue: Optional[DatasetContentVersionValue] = None
    doubleValue: Optional[DoubleValue] = None
    name: VariableName
    outputFileUriValue: Optional[OutputFileUriValue] = None
    stringValue: Optional[StringValue] = None


class Variables(RootModel[List[Variable]]):
    root: List[Variable] = Field(..., max_length=50, min_length=0)


class ChannelStorage(BaseModel):
    customerManagedS3: Optional[CustomerManagedChannelS3Storage] = None
    serviceManagedS3: Optional[ServiceManagedChannelS3Storage] = None


class ChannelsPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    channelName: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Field(..., description='The name of the channel.')
    channelStorage: Optional[ChannelStorage] = Field(
        None,
        description="Where channel data is stored. You may choose one of <code>serviceManagedS3</code>, <code>customerManagedS3</code> storage. If not specified, the default is <code>serviceManagedS3</code>. This can't be changed after creation of the channel.",
    )
    retentionPeriod: Optional[RetentionPeriod] = Field(
        None, description='How long, in days, message data is kept.'
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='Metadata which can be used to manage the channel.',
        max_length=50,
        min_length=1,
    )


class ChannelsChannelNamePutRequest(BaseModel):
    channelStorage: Optional[ChannelStorage] = Field(
        None,
        description="Where channel data is stored. You may choose one of <code>serviceManagedS3</code>, <code>customerManagedS3</code> storage. If not specified, the default is <code>serviceManagedS3</code>. This can't be changed after creation of the channel.",
    )
    retentionPeriod: Optional[RetentionPeriod] = Field(
        None, description='How long, in days, message data is kept.'
    )


class MessagesBatchPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    channelName: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Field(..., description='The name of the channel where the messages are sent.')
    messages: List[Message] = Field(
        ...,
        description='<p>The list of messages to be sent. Each message has the format: { "messageId": "string", "payload": "string"}.</p> <p>The field names of message payloads (data) that you send to IoT Analytics:</p> <ul> <li> <p>Must contain only alphanumeric characters and undescores (_). No other special characters are allowed.</p> </li> <li> <p>Must begin with an alphabetic character or single underscore (_).</p> </li> <li> <p>Cannot contain hyphens (-).</p> </li> <li> <p>In regular expression terms: "^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$". </p> </li> <li> <p>Cannot be more than 255 characters.</p> </li> <li> <p>Are case insensitive. (Fields named foo and FOO in the same payload are considered duplicates.)</p> </li> </ul> <p>For example, {"temp_01": 29} or {"_temp_01": 29} are valid, but {"temp-01": 29}, {"01_temp": 29} or {"__temp_01": 29} are invalid in message payloads. </p>',
    )


class PipelineactivitiesRunPostRequest(BaseModel):
    payloads: List[MessagePayload] = Field(
        ...,
        description='The sample message payloads on which the pipeline activity is run.',
        max_length=10,
        min_length=1,
    )
    pipelineActivity: PipelineActivity = Field(
        ..., description='An activity that performs a transformation on a message.'
    )


class PipelinesPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    pipelineActivities: List[PipelineActivity] = Field(
        ...,
        description='<p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on your messages, such as removing, renaming or adding message attributes; filtering messages based on attribute values; invoking your Lambda unctions on messages for advanced processing; or performing mathematical transformations to normalize device data.</p> <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must contain only one activity. For example:</p> <p> <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ... ]</code> </p>',
        max_length=25,
        min_length=1,
    )
    pipelineName: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Field(..., description='The name of the pipeline.')
    tags: Optional[List[Tag]] = Field(
        None,
        description='Metadata which can be used to manage the pipeline.',
        max_length=50,
        min_length=1,
    )


class PipelinesPipelineNamePutRequest(BaseModel):
    pipelineActivities: List[PipelineActivity] = Field(
        ...,
        description='<p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on your messages, such as removing, renaming or adding message attributes; filtering messages based on attribute values; invoking your Lambda functions on messages for advanced processing; or performing mathematical transformations to normalize device data.</p> <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must contain only one activity. For example:</p> <p> <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ... ]</code> </p>',
        max_length=25,
        min_length=1,
    )


class TagsResourceArnPostRequest(BaseModel):
    tags: List[Tag] = Field(
        ...,
        description='The new or modified tags for the resource.',
        max_length=50,
        min_length=1,
    )


class BatchPutMessageErrorEntries(RootModel[List[BatchPutMessageErrorEntry]]):
    root: List[BatchPutMessageErrorEntry]


class BatchPutMessageRequest(BaseModel):
    channelName: ChannelName
    messages: Messages


class BatchPutMessageResponse(BaseModel):
    batchPutMessageErrorEntries: Optional[BatchPutMessageErrorEntries] = None


class ChannelStatistics(BaseModel):
    size: Optional[EstimatedResourceSize] = None


class ChannelStorageSummary(BaseModel):
    customerManagedS3: Optional[CustomerManagedChannelS3StorageSummary] = None
    serviceManagedS3: Optional[ServiceManagedChannelS3StorageSummary] = None


class ChannelSummary(BaseModel):
    channelName: Optional[ChannelName] = None
    channelStorage: Optional[ChannelStorageSummary] = None
    creationTime: Optional[Timestamp] = None
    lastMessageArrivalTime: Optional[Timestamp] = None
    lastUpdateTime: Optional[Timestamp] = None
    status: Optional[ChannelStatus] = None


class ContainerDatasetAction(BaseModel):
    executionRoleArn: RoleArn
    image: Image
    resourceConfiguration: ResourceConfiguration
    variables: Optional[Variables] = None


class CreateChannelRequest(BaseModel):
    channelName: ChannelName
    channelStorage: Optional[ChannelStorage] = None
    retentionPeriod: Optional[RetentionPeriod] = None
    tags: Optional[TagList] = None


class CreateChannelResponse(BaseModel):
    channelArn: Optional[ChannelArn] = None
    channelName: Optional[ChannelName] = None
    retentionPeriod: Optional[RetentionPeriod] = None


class CreateDatasetResponse(BaseModel):
    datasetArn: Optional[DatasetArn] = None
    datasetName: Optional[DatasetName] = None
    retentionPeriod: Optional[RetentionPeriod] = None


class CreateDatastoreResponse(BaseModel):
    datastoreArn: Optional[DatastoreArn] = None
    datastoreName: Optional[DatastoreName] = None
    retentionPeriod: Optional[RetentionPeriod] = None


class DatasetAction(BaseModel):
    actionName: Optional[DatasetActionName] = None
    containerAction: Optional[ContainerDatasetAction] = None
    queryAction: Optional[SqlQueryDatasetAction] = None


class DatasetActionSummaries(RootModel[List[DatasetActionSummary]]):
    root: List[DatasetActionSummary] = Field(..., max_length=1, min_length=1)


class DatasetActions(RootModel[List[DatasetAction]]):
    root: List[DatasetAction] = Field(..., max_length=1, min_length=1)


class DatasetContentDeliveryDestination(BaseModel):
    iotEventsDestinationConfiguration: Optional[IotEventsDestinationConfiguration] = (
        None
    )
    s3DestinationConfiguration: Optional[S3DestinationConfiguration] = None


class DatasetContentDeliveryRule(BaseModel):
    destination: DatasetContentDeliveryDestination
    entryName: Optional[EntryName] = None


class DatasetContentDeliveryRules(RootModel[List[DatasetContentDeliveryRule]]):
    root: List[DatasetContentDeliveryRule] = Field(..., max_length=20, min_length=0)


class DatasetContentSummaries(RootModel[List[DatasetContentSummary]]):
    root: List[DatasetContentSummary]


class DatasetEntries(RootModel[List[DatasetEntry]]):
    root: List[DatasetEntry]


class DatasetTrigger(BaseModel):
    dataset: Optional[TriggeringDataset] = None
    schedule: Optional[Schedule] = None


class DatasetTriggers(RootModel[List[DatasetTrigger]]):
    root: List[DatasetTrigger] = Field(..., max_length=5, min_length=0)


class DatastoreIotSiteWiseMultiLayerStorage(BaseModel):
    customerManagedS3Storage: IotSiteWiseCustomerManagedDatastoreS3Storage


class DatastoreIotSiteWiseMultiLayerStorageSummary(BaseModel):
    customerManagedS3Storage: Optional[
        IotSiteWiseCustomerManagedDatastoreS3StorageSummary
    ] = None


class DatastorePartition(BaseModel):
    attributePartition: Optional[Partition] = None
    timestampPartition: Optional[TimestampPartition] = None


class DatastoreStatistics(BaseModel):
    size: Optional[EstimatedResourceSize] = None


class DatastoreStorage(BaseModel):
    customerManagedS3: Optional[CustomerManagedDatastoreS3Storage] = None
    iotSiteWiseMultiLayerStorage: Optional[DatastoreIotSiteWiseMultiLayerStorage] = None
    serviceManagedS3: Optional[ServiceManagedDatastoreS3Storage] = None


class DatastoreStorageSummary(BaseModel):
    customerManagedS3: Optional[CustomerManagedDatastoreS3StorageSummary] = None
    iotSiteWiseMultiLayerStorage: Optional[
        DatastoreIotSiteWiseMultiLayerStorageSummary
    ] = None
    serviceManagedS3: Optional[ServiceManagedDatastoreS3StorageSummary] = None


class DescribeLoggingOptionsResponse(BaseModel):
    loggingOptions: Optional[LoggingOptions] = None


class GetDatasetContentResponse(BaseModel):
    entries: Optional[DatasetEntries] = None
    status: Optional[DatasetContentStatus] = None
    timestamp: Optional[Timestamp] = None


class LateDataRule(BaseModel):
    ruleConfiguration: LateDataRuleConfiguration
    ruleName: Optional[LateDataRuleName] = None


class LateDataRules(RootModel[List[LateDataRule]]):
    root: List[LateDataRule] = Field(..., max_length=1, min_length=1)


class ListDatasetContentsResponse(BaseModel):
    datasetContentSummaries: Optional[DatasetContentSummaries] = None
    nextToken: Optional[NextToken] = None


class ListTagsForResourceResponse(BaseModel):
    tags: Optional[TagList] = None


class ParquetConfiguration(BaseModel):
    schemaDefinition: Optional[SchemaDefinition] = None


class Partitions(RootModel[List[DatastorePartition]]):
    root: List[DatastorePartition] = Field(..., max_length=25, min_length=0)


class PipelineActivities(RootModel[List[PipelineActivity]]):
    root: List[PipelineActivity] = Field(..., max_length=25, min_length=1)


class ReprocessingSummaries(RootModel[List[ReprocessingSummary]]):
    root: List[ReprocessingSummary]


class UpdateChannelRequest(BaseModel):
    channelStorage: Optional[ChannelStorage] = None
    retentionPeriod: Optional[RetentionPeriod] = None


class UpdateDatasetRequest(BaseModel):
    actions: DatasetActions
    contentDeliveryRules: Optional[DatasetContentDeliveryRules] = None
    lateDataRules: Optional[LateDataRules] = None
    retentionPeriod: Optional[RetentionPeriod] = None
    triggers: Optional[DatasetTriggers] = None
    versioningConfiguration: Optional[VersioningConfiguration] = None


class UpdatePipelineRequest(BaseModel):
    pipelineActivities: PipelineActivities


class DatasetsPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    actions: List[DatasetAction] = Field(
        ...,
        description='A list of actions that create the dataset contents.',
        max_length=1,
        min_length=1,
    )
    contentDeliveryRules: Optional[List[DatasetContentDeliveryRule]] = Field(
        None,
        description='When dataset contents are created, they are delivered to destinations specified here.',
        max_length=20,
        min_length=0,
    )
    datasetName: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Field(..., description='The name of the dataset.')
    lateDataRules: Optional[List[LateDataRule]] = Field(
        None,
        description='A list of data rules that send notifications to CloudWatch, when data arrives late. To specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a> filter.',
        max_length=1,
        min_length=1,
    )
    retentionPeriod: Optional[RetentionPeriod] = Field(
        None, description='How long, in days, message data is kept.'
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='Metadata which can be used to manage the dataset.',
        max_length=50,
        min_length=1,
    )
    triggers: Optional[List[DatasetTrigger]] = Field(
        None,
        description="A list of triggers. A trigger causes dataset contents to be populated at a specified time interval or when another dataset's contents are created. The list of triggers can be empty or contain up to five <code>DataSetTrigger</code> objects.",
        max_length=5,
        min_length=0,
    )
    versioningConfiguration: Optional[VersioningConfiguration] = Field(
        None, description='Information about the versioning of dataset contents.'
    )


class DatasetsDatasetNamePutRequest(BaseModel):
    actions: List[DatasetAction] = Field(
        ...,
        description='A list of <code>DatasetAction</code> objects.',
        max_length=1,
        min_length=1,
    )
    contentDeliveryRules: Optional[List[DatasetContentDeliveryRule]] = Field(
        None,
        description='When dataset contents are created, they are delivered to destinations specified here.',
        max_length=20,
        min_length=0,
    )
    lateDataRules: Optional[List[LateDataRule]] = Field(
        None,
        description='A list of data rules that send notifications to CloudWatch, when data arrives late. To specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a> filter.',
        max_length=1,
        min_length=1,
    )
    retentionPeriod: Optional[RetentionPeriod] = Field(
        None, description='How long, in days, message data is kept.'
    )
    triggers: Optional[List[DatasetTrigger]] = Field(
        None,
        description='A list of <code>DatasetTrigger</code> objects. The list can be empty or can contain up to five <code>DatasetTrigger</code> objects.',
        max_length=5,
        min_length=0,
    )
    versioningConfiguration: Optional[VersioningConfiguration] = Field(
        None, description='Information about the versioning of dataset contents.'
    )


class DatastorePartitions(BaseModel):
    partitions: Optional[Partitions] = None


class FileFormatConfiguration(BaseModel):
    jsonConfiguration: Optional[JsonConfiguration] = None
    parquetConfiguration: Optional[ParquetConfiguration] = None


class DatastoresPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    datastoreName: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Field(..., description='The name of the data store.')
    datastorePartitions: Optional[DatastorePartitions] = Field(
        None,
        description=' Contains information about the partition dimensions in a data store. ',
    )
    datastoreStorage: Optional[DatastoreStorage] = Field(
        None,
        description="Where data in a data store is stored.. You can choose <code>serviceManagedS3</code> storage, <code>customerManagedS3</code> storage, or <code>iotSiteWiseMultiLayerStorage</code> storage. The default is <code>serviceManagedS3</code>. You can't change the choice of Amazon S3 storage after your data store is created. ",
    )
    fileFormatConfiguration: Optional[FileFormatConfiguration] = Field(
        None,
        description='<p>Contains the configuration information of file formats. IoT Analytics data stores support JSON and <a href="https://parquet.apache.org/">Parquet</a>.</p> <p>The default file format is JSON. You can specify only one format.</p> <p>You can\'t change the file format after you create the data store.</p>',
    )
    retentionPeriod: Optional[RetentionPeriod] = Field(
        None, description='How long, in days, message data is kept.'
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='Metadata which can be used to manage the data store.',
        max_length=50,
        min_length=1,
    )


class DatastoresDatastoreNamePutRequest(BaseModel):
    datastoreStorage: Optional[DatastoreStorage] = Field(
        None,
        description="Where data in a data store is stored.. You can choose <code>serviceManagedS3</code> storage, <code>customerManagedS3</code> storage, or <code>iotSiteWiseMultiLayerStorage</code> storage. The default is <code>serviceManagedS3</code>. You can't change the choice of Amazon S3 storage after your data store is created. ",
    )
    fileFormatConfiguration: Optional[FileFormatConfiguration] = Field(
        None,
        description='<p>Contains the configuration information of file formats. IoT Analytics data stores support JSON and <a href="https://parquet.apache.org/">Parquet</a>.</p> <p>The default file format is JSON. You can specify only one format.</p> <p>You can\'t change the file format after you create the data store.</p>',
    )
    retentionPeriod: Optional[RetentionPeriod] = Field(
        None, description='How long, in days, message data is kept.'
    )


class Channel(BaseModel):
    arn: Optional[ChannelArn] = None
    creationTime: Optional[Timestamp] = None
    lastMessageArrivalTime: Optional[Timestamp] = None
    lastUpdateTime: Optional[Timestamp] = None
    name: Optional[ChannelName] = None
    retentionPeriod: Optional[RetentionPeriod] = None
    status: Optional[ChannelStatus] = None
    storage: Optional[ChannelStorage] = None


class ChannelSummaries(RootModel[List[ChannelSummary]]):
    root: List[ChannelSummary]


class CreateDatasetRequest(BaseModel):
    actions: DatasetActions
    contentDeliveryRules: Optional[DatasetContentDeliveryRules] = None
    datasetName: DatasetName
    lateDataRules: Optional[LateDataRules] = None
    retentionPeriod: Optional[RetentionPeriod] = None
    tags: Optional[TagList] = None
    triggers: Optional[DatasetTriggers] = None
    versioningConfiguration: Optional[VersioningConfiguration] = None


class CreatePipelineRequest(BaseModel):
    pipelineActivities: PipelineActivities
    pipelineName: PipelineName
    tags: Optional[TagList] = None


class Dataset(BaseModel):
    actions: Optional[DatasetActions] = None
    arn: Optional[DatasetArn] = None
    contentDeliveryRules: Optional[DatasetContentDeliveryRules] = None
    creationTime: Optional[Timestamp] = None
    lastUpdateTime: Optional[Timestamp] = None
    lateDataRules: Optional[LateDataRules] = None
    name: Optional[DatasetName] = None
    retentionPeriod: Optional[RetentionPeriod] = None
    status: Optional[DatasetStatus] = None
    triggers: Optional[DatasetTriggers] = None
    versioningConfiguration: Optional[VersioningConfiguration] = None


class DatasetSummary(BaseModel):
    actions: Optional[DatasetActionSummaries] = None
    creationTime: Optional[Timestamp] = None
    datasetName: Optional[DatasetName] = None
    lastUpdateTime: Optional[Timestamp] = None
    status: Optional[DatasetStatus] = None
    triggers: Optional[DatasetTriggers] = None


class DatastoreSummary(BaseModel):
    creationTime: Optional[Timestamp] = None
    datastoreName: Optional[DatastoreName] = None
    datastorePartitions: Optional[DatastorePartitions] = None
    datastoreStorage: Optional[DatastoreStorageSummary] = None
    fileFormatType: Optional[FileFormatType] = None
    lastMessageArrivalTime: Optional[Timestamp] = None
    lastUpdateTime: Optional[Timestamp] = None
    status: Optional[DatastoreStatus] = None


class DescribeChannelResponse(BaseModel):
    channel: Optional[Channel] = None
    statistics: Optional[ChannelStatistics] = None


class DescribeDatasetResponse(BaseModel):
    dataset: Optional[Dataset] = None


class ListChannelsResponse(BaseModel):
    channelSummaries: Optional[ChannelSummaries] = None
    nextToken: Optional[NextToken] = None


class Pipeline(BaseModel):
    activities: Optional[PipelineActivities] = None
    arn: Optional[PipelineArn] = None
    creationTime: Optional[Timestamp] = None
    lastUpdateTime: Optional[Timestamp] = None
    name: Optional[PipelineName] = None
    reprocessingSummaries: Optional[ReprocessingSummaries] = None


class PipelineSummary(BaseModel):
    creationTime: Optional[Timestamp] = None
    lastUpdateTime: Optional[Timestamp] = None
    pipelineName: Optional[PipelineName] = None
    reprocessingSummaries: Optional[ReprocessingSummaries] = None


class UpdateDatastoreRequest(BaseModel):
    datastoreStorage: Optional[DatastoreStorage] = None
    fileFormatConfiguration: Optional[FileFormatConfiguration] = None
    retentionPeriod: Optional[RetentionPeriod] = None


class CreateDatastoreRequest(BaseModel):
    datastoreName: DatastoreName
    datastorePartitions: Optional[DatastorePartitions] = None
    datastoreStorage: Optional[DatastoreStorage] = None
    fileFormatConfiguration: Optional[FileFormatConfiguration] = None
    retentionPeriod: Optional[RetentionPeriod] = None
    tags: Optional[TagList] = None


class DatasetSummaries(RootModel[List[DatasetSummary]]):
    root: List[DatasetSummary]


class Datastore(BaseModel):
    arn: Optional[DatastoreArn] = None
    creationTime: Optional[Timestamp] = None
    datastorePartitions: Optional[DatastorePartitions] = None
    fileFormatConfiguration: Optional[FileFormatConfiguration] = None
    lastMessageArrivalTime: Optional[Timestamp] = None
    lastUpdateTime: Optional[Timestamp] = None
    name: Optional[DatastoreName] = None
    retentionPeriod: Optional[RetentionPeriod] = None
    status: Optional[DatastoreStatus] = None
    storage: Optional[DatastoreStorage] = None


class DatastoreSummaries(RootModel[List[DatastoreSummary]]):
    root: List[DatastoreSummary]


class DescribeDatastoreResponse(BaseModel):
    datastore: Optional[Datastore] = None
    statistics: Optional[DatastoreStatistics] = None


class DescribePipelineResponse(BaseModel):
    pipeline: Optional[Pipeline] = None


class ListDatasetsResponse(BaseModel):
    datasetSummaries: Optional[DatasetSummaries] = None
    nextToken: Optional[NextToken] = None


class ListDatastoresResponse(BaseModel):
    datastoreSummaries: Optional[DatastoreSummaries] = None
    nextToken: Optional[NextToken] = None


class PipelineSummaries(RootModel[List[PipelineSummary]]):
    root: List[PipelineSummary]


class ListPipelinesResponse(BaseModel):
    nextToken: Optional[NextToken] = None
    pipelineSummaries: Optional[PipelineSummaries] = None
