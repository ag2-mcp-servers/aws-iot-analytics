# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:04:45+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    BatchPutMessageResponse,
    CancelPipelineReprocessingResponse,
    ChannelsChannelNamePutRequest,
    ChannelsPostRequest,
    CreateChannelResponse,
    CreateDatasetContentResponse,
    CreateDatasetResponse,
    CreateDatastoreResponse,
    CreatePipelineResponse,
    DatasetsDatasetNameContentPostRequest,
    DatasetsDatasetNamePutRequest,
    DatasetsPostRequest,
    DatastoresDatastoreNamePutRequest,
    DatastoresPostRequest,
    DescribeChannelResponse,
    DescribeDatasetResponse,
    DescribeDatastoreResponse,
    DescribeLoggingOptionsResponse,
    DescribePipelineResponse,
    GetDatasetContentResponse,
    InternalFailureException,
    InvalidRequestException,
    LimitExceededException,
    ListChannelsResponse,
    ListDatasetContentsResponse,
    ListDatasetsResponse,
    ListDatastoresResponse,
    ListPipelinesResponse,
    ListTagsForResourceResponse,
    LoggingPutRequest,
    MessagesBatchPostRequest,
    PipelineactivitiesRunPostRequest,
    PipelinesPipelineNamePutRequest,
    PipelinesPipelineNameReprocessingPostRequest,
    PipelinesPostRequest,
    ResourceAlreadyExistsException,
    ResourceNotFoundException,
    RunPipelineActivityResponse,
    SampleChannelDataResponse,
    ServiceUnavailableException,
    StartPipelineReprocessingResponse,
    TagKeys,
    TagResourceResponse,
    TagsResourceArnPostRequest,
    ThrottlingException,
    UntagResourceResponse,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<p>IoT Analytics allows you to collect large amounts of device data, process messages, and store them. You can then query the data and run sophisticated analytics on it. IoT Analytics enables advanced data exploration through integration with Jupyter Notebooks and data visualization through integration with Amazon QuickSight.</p> <p>Traditional analytics and business intelligence tools are designed to process structured data. IoT data often comes from devices that record noisy processes (such as temperature, motion, or sound). As a result the data from these devices can have significant gaps, corrupted messages, and false readings that must be cleaned up before analysis can occur. Also, IoT data is often only meaningful in the context of other data from external sources. </p> <p>IoT Analytics automates the steps required to analyze data from IoT devices. IoT Analytics filters, transforms, and enriches IoT data before storing it in a time-series data store for analysis. You can set up the service to collect only the data you need from your devices, apply mathematical transforms to process the data, and enrich the data with device-specific metadata such as device type and location before storing it. Then, you can analyze your data by running queries using the built-in SQL query engine, or perform more complex analytics and machine learning inference. IoT Analytics includes pre-built models for common IoT use cases so you can answer questions like which devices are about to fail or which customers are at risk of abandoning their wearable devices.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS IoT Analytics',
    version='2017-11-27',
    servers=[
        {
            'description': 'The AWS IoT Analytics multi-region endpoint',
            'url': 'http://iotanalytics.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS IoT Analytics multi-region endpoint',
            'url': 'https://iotanalytics.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS IoT Analytics endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://iotanalytics.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AWS IoT Analytics endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://iotanalytics.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/channels',
    description=""" Retrieves a list of channels. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_channels(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=250)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/channels',
    description=""" Used to create a channel. A channel collects data from an MQTT topic and archives the raw, unprocessed messages before publishing the data to a pipeline. """,
    tags=['channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_channel(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ChannelsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/channels/{channelName}',
    description=""" Deletes the specified channel. """,
    tags=['channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_channel(
    channel_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='channelName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/channels/{channelName}',
    description=""" Retrieves information about a channel. """,
    tags=['channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_channel(
    channel_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='channelName'),
    include_statistics: Optional[bool] = Query(None, alias='includeStatistics'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/channels/{channelName}',
    description=""" Used to update the settings of a channel. """,
    tags=['channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_channel(
    channel_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='channelName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ChannelsChannelNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/channels/{channelName}/sample',
    description=""" Retrieves a sample of messages from the specified channel ingested during the specified timeframe. Up to 10 messages can be retrieved. """,
    tags=['channel_management', 'bulk_message_processing'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def sample_channel_data(
    channel_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='channelName'),
    max_messages: Optional[conint(ge=1, le=10)] = Query(None, alias='maxMessages'),
    start_time: Optional[datetime] = Query(None, alias='startTime'),
    end_time: Optional[datetime] = Query(None, alias='endTime'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datasets',
    description=""" Retrieves information about datasets. """,
    tags=['datastore_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_datasets(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=250)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/datasets',
    description=""" Used to create a dataset. A dataset stores data retrieved from a data store by applying a <code>queryAction</code> (a SQL query) or a <code>containerAction</code> (executing a containerized application). This operation creates the skeleton of a dataset. The dataset can be populated manually by calling <code>CreateDatasetContent</code> or automatically according to a trigger you specify. """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_dataset(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DatasetsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/datasets/{datasetName}',
    description=""" <p>Deletes the specified dataset.</p> <p>You do not have to delete the content of the dataset before you perform this operation.</p> """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_dataset(
    dataset_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datasetName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datasets/{datasetName}',
    description=""" Retrieves information about a dataset. """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_dataset(
    dataset_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datasetName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/datasets/{datasetName}',
    description=""" Updates the settings of a dataset. """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_dataset(
    dataset_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datasetName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DatasetsDatasetNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/datasets/{datasetName}/content',
    description=""" Deletes the content of the specified dataset. """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_dataset_content(
    dataset_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datasetName'),
    version_id: Optional[constr(min_length=7, max_length=36)] = Query(
        None, alias='versionId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datasets/{datasetName}/content',
    description=""" Retrieves the contents of a dataset as presigned URIs. """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_dataset_content(
    dataset_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datasetName'),
    version_id: Optional[constr(min_length=7, max_length=36)] = Query(
        None, alias='versionId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/datasets/{datasetName}/content',
    description=""" Creates the content of a dataset by applying a <code>queryAction</code> (a SQL query) or a <code>containerAction</code> (executing a containerized application). """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_dataset_content(
    dataset_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datasetName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DatasetsDatasetNameContentPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datasets/{datasetName}/contents',
    description=""" Lists information about dataset contents that have been created. """,
    tags=['dataset_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_dataset_contents(
    dataset_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datasetName'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=250)] = Query(None, alias='maxResults'),
    scheduled_on_or_after: Optional[datetime] = Query(None, alias='scheduledOnOrAfter'),
    scheduled_before: Optional[datetime] = Query(None, alias='scheduledBefore'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datastores',
    description=""" Retrieves a list of data stores. """,
    tags=['pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_datastores(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=250)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/datastores',
    description=""" Creates a data store, which is a repository for messages. """,
    tags=['datastore_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_datastore(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DatastoresPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/datastores/{datastoreName}',
    description=""" Deletes the specified data store. """,
    tags=['datastore_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_datastore(
    datastore_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datastoreName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datastores/{datastoreName}',
    description=""" Retrieves information about a data store. """,
    tags=['datastore_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_datastore(
    datastore_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datastoreName'),
    include_statistics: Optional[bool] = Query(None, alias='includeStatistics'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/datastores/{datastoreName}',
    description=""" Used to update the settings of a data store. """,
    tags=['datastore_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_datastore(
    datastore_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='datastoreName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DatastoresDatastoreNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/logging',
    description=""" Retrieves the current settings of the IoT Analytics logging options. """,
    tags=[
        'channel_management',
        'dataset_management',
        'datastore_management',
        'pipeline_handling',
        'logging_setup',
        'bulk_message_processing',
        'pipeline_control',
        'resource_tag_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_logging_options(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/logging',
    description=""" <p>Sets or updates the IoT Analytics logging options.</p> <p>If you update the value of any <code>loggingOptions</code> field, it takes up to one minute for the change to take effect. Also, if you change the policy attached to the role you specified in the <code>roleArn</code> field (for example, to correct an invalid policy), it takes up to five minutes for that change to take effect. </p> """,
    tags=['logging_setup'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_logging_options(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: LoggingPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messages/batch',
    description=""" Sends messages to a channel. """,
    tags=['bulk_message_processing'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def batch_put_message(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MessagesBatchPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/pipelineactivities/run',
    description=""" Simulates the results of running a pipeline activity on a message payload. """,
    tags=['pipeline_handling', 'pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def run_pipeline_activity(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PipelineactivitiesRunPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pipelines',
    description=""" Retrieves a list of pipelines. """,
    tags=['pipeline_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_pipelines(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=250)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/pipelines',
    description=""" Creates a pipeline. A pipeline consumes messages from a channel and allows you to process the messages before storing them in a data store. You must specify both a <code>channel</code> and a <code>datastore</code> activity and, optionally, as many as 23 additional activities in the <code>pipelineActivities</code> array. """,
    tags=['pipeline_handling', 'pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_pipeline(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PipelinesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/pipelines/{pipelineName}',
    description=""" Deletes the specified pipeline. """,
    tags=['pipeline_handling', 'pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_pipeline(
    pipeline_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='pipelineName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pipelines/{pipelineName}',
    description=""" Retrieves information about a pipeline. """,
    tags=['pipeline_handling', 'pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_pipeline(
    pipeline_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='pipelineName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/pipelines/{pipelineName}',
    description=""" Updates the settings of a pipeline. You must specify both a <code>channel</code> and a <code>datastore</code> activity and, optionally, as many as 23 additional activities in the <code>pipelineActivities</code> array. """,
    tags=['pipeline_handling', 'pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_pipeline(
    pipeline_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='pipelineName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PipelinesPipelineNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/pipelines/{pipelineName}/reprocessing',
    description=""" Starts the reprocessing of raw message data through the pipeline. """,
    tags=['pipeline_handling', 'pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_pipeline_reprocessing(
    pipeline_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='pipelineName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PipelinesPipelineNameReprocessingPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/pipelines/{pipelineName}/reprocessing/{reprocessingId}',
    description=""" Cancels the reprocessing of data through the pipeline. """,
    tags=['pipeline_handling', 'pipeline_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def cancel_pipeline_reprocessing(
    pipeline_name: constr(
        pattern=r'(^(?!_{2}))(^[a-zA-Z0-9_]+$)', min_length=1, max_length=128
    ) = Path(..., alias='pipelineName'),
    reprocessing_id: str = Path(..., alias='reprocessingId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags#resourceArn',
    description=""" Lists the tags (metadata) that you have assigned to the resource. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: constr(min_length=20, max_length=2048) = Query(
        ..., alias='resourceArn'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags#resourceArn',
    description=""" Adds to or modifies the tags of the given resource. Tags are metadata that can be used to manage a resource. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: constr(min_length=20, max_length=2048) = Query(
        ..., alias='resourceArn'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags#resourceArn&tagKeys',
    description=""" Removes the given tags (metadata) from the resource. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: constr(min_length=20, max_length=2048) = Query(
        ..., alias='resourceArn'
    ),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
